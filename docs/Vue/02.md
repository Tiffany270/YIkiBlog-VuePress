# vue源码 构造和合并

:) 从现在开始好好学习

## GlobalAPI
- src/core/index.js 当这里是入口吧
``` js
import Vue from './instance/index' 
import { initGlobalAPI } from './global-api/index'
...
initGlobalAPI(Vue) //这里的vue从instence里来的
... 
```
- 静态属性方法src/globalapi/index/下的
    - `initGlobalAPI` 全局api方法
    ``` js
    ...
    // 对config的处理
    const configDef = {}
    configDef.get = () => config
    if (process.env.NODE_ENV !== 'production') {
        configDef.set = () => {
        warn(
            'Do not replace the Vue.config object, set individual fields instead.'
        )
        }
    }
    Object.defineProperty(Vue, 'config', configDef)
    //...

    Vue.set = set
    Vue.delete = del
    Vue.nextTick = nextTick

    //option    
    Vue.options = Object.create(null)
    // 'component','directive','filter'
    ASSET_TYPES.forEach(type => {
        Vue.options[type + 's'] = Object.create(null)
    })
    //还有一些绑定在component上的扩展，见builtInComponents里
    extend(Vue.options.components, builtInComponents)
    //
    initUse(Vue)//Vue.use = function (plugin: Function | Object)
    initMixin(Vue)// Vue.mixin = function (mixin: Object)
    initExtend(Vue)// Vue.extend = function (extendOptions: Object): Function 
    initAssetRegisters(Vue) //ASSET_TYPES 'component','directive','filter'

    ```
- `builtInComponents`
- 子类构造器src/globalapi/extend.js
    - 对子类和父类的optio进行合并
    ``` js
    Vue.extend = function (extendOptions: Object){
        ...
    }
    ```
## instance
- src/core/instance/index.js
    ``` js
    // yiki1 打包后的源码是遵从UMD规范的，它是commonjs和amd的整合。
    // 而Vue的本质是一个构造器,并且它保证了只能通过new实例的形式去调用，而不能直接通过函数的形式使用
    function Vue (options) {
    if (process.env.NODE_ENV !== 'production' &&
        !(this instanceof Vue)
    ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
    }
    this._init(options)
    }
    // 定义Vue原型上的init方法(内部方法)
    initMixin(Vue)
    // 定义原型上跟数据相关的属性方法
    stateMixin(Vue)
    //定义原型上跟事件相关的属性方法
    eventsMixin(Vue)
    // 定义原型上跟生命周期相关的方法
    lifecycleMixin(Vue)
    // 定义渲染相关的函数
    renderMixin(Vue)

    export default Vue
    ```
## initMixin 
- 原型上的`_init`方法
``` js
Vue.prototype._init = function (options?: Object)
...
 vm.$options = mergeOptions(// 合并选项（这是用我们写的option）
        resolveConstructorOptions(vm.constructor),// 返回构造函数自身的配置项
        options || {},
        vm
      )
...
if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)// 响应式拦截代理
    } else {
      vm._renderProxy = vm
    }
...
 // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
```
- 选项合并 `mergeOptions`
``` js
vm.$options = mergeOptions(// 合并选项（这是用我们写的option）
resolveConstructorOptions(vm.constructor),// 返回构造函数自身的配置项
options || {},
vm
)
```
- 响应式数据拦截 `initProxy(vm)`
``` js
 if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)// 响应式拦截代理
    } else {
      vm._renderProxy = vm
  }
```
- `initState(vm)` /core/instance/state.js
``` js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props) // props
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```
## stateMixin
- 跟数据相关的属性方法
``` js
Object.defineProperty(Vue.prototype, '$data', dataDef)
Object.defineProperty(Vue.prototype, '$props', propsDef)
Vue.prototype.$set = set
Vue.prototype.$delete = del
Vue.prototype.$watch = function (...)
```
## eventsMixin
- 对原型上的事件相关方法
``` js
Vue.prototype.$on = function (...)
Vue.prototype.$once = function (...)
Vue.prototype.$off = function()
Vue.prototype.$emit = function(
  ...
  let cbs = vm._events[event]
    if (cbs) {
      ...
)
```
- vue在实例上用了一个`vm_events`属性来存储管理事件的派发和更新，并暴露了这些api给外鼓管理和派发
- 理解`$emit`通信原理就是事件监听的回调卸载了父组件中
## lifecycleMixin
- 生命周期相关
``` js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean)
Vue.prototype.$forceUpdate = function ()
Vue.prototype.$destroy = function () 
```
## renderMixin
- 渲染相关
``` js
Vue.prototype.$nextTick = function()
Vue.prototype._render = function (): VNode 
```
## mergeOptions
- /src/core/util/options.js,同一个文件里面有很多关于合并选项的规则
``` js
/**
* Merge two option objects into a new one.
* Core utility used in both instantiation and inheritance.
*/
export function mergeOptions (
parent: Object,
child: Object,
vm?: Component
): Object {
if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)// 拿到option之前要先校验规范
}
if (typeof child === 'function') {
    child = child.options
}
// props,inject,directives的校验和规范化
normalizeProps(child, vm)
normalizeInject(child, vm)
normalizeDirectives(child)
// 扩展子类构造器
if (!child._base) {
    if (child.extends) {
    parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
    for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
    }
    }
}
const options = {}
let key
for (key in parent) {
    mergeField(key)
}
for (key in child) {
    if (!hasOwn(parent, key)) {
    mergeField(key)
    }
}
function mergeField (key) {
    // 拿到指定的选项配置，如果没有则用默认的配置
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
}
return options
}

```
- `validateComponentName() `注册组件名的规则
- `normalizeProps()`
- `normalizeInject()` 用于`provide/inject`的规则
- `normalizeDirectives()` 针对`directives`会针对写法将行为赋予`bind/update`钩子
``` js
...
    if (typeof def === 'function') {
    dirs[key] = { bind: def, update: def }
    }
```
- el 的合并
``` js
strats.el = strats.propsData = function (parent, child, vm, key) {
if (!vm) {// 只允许vue实例才能拥有el属性，其他子类不允许
    warn(
    `option "${key}" can only be used during instance ` +
    'creation with the `new` keyword.'
    )
}
return defaultStrat(parent, child)
}
}
```
- data 的合并
``` js
/**
 * Data
 * 合并返回mergeDatafn or mergedInstanceDataFn funciton
 * 为了复用，每次创建都在一个闭包里，相当于独立的空间，这样每个组件之间的数据就不会相互影响
 */
export function mergeDataOrFn (
  parentVal: any,
  childVal: any,
  vm?: Component
): ?Function {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      const instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal
      const defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData // 不传递data时返回默认
      }
    }
  }
}
strats.data = function (
  parentVal: any,
  childVal: any,
  vm?: Component
): ?Function {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {// 保证子类data是一个函数
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      )
      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }
  return mergeDataOrFn(parentVal, childVal, vm)
}
```
- watch选项合并

