# 浏览器性能

## 进程和线程
- 打开浏览器一个进程、打开音乐一个进程
- 进程里面含多个线程、浏览器点击一个线程、切换一个线程 etc
- 但是浏览器是进程的！互不影响。
- ![img](./process_list.png)
## js单线程
- 为了造成ui渲染的不冲突，JS 引擎一直等待着`任务队列`中任务的到来,然后加以处理
- 无论什么时候都`只有一个` JS 线程在运行 JS 程序

## 浏览器渲染流程
- 解析 HTML 文件,构建 `DOM` 树,同时浏览器主进程负责下载 样式/css 文件
- 样式文件下载完成,解析CSS文件成树形的数据结构,然后结合 DOM 树合并成 `RenderObject` 树
- 布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算
- `绘制` RenderObject 树 （paint）,绘制页面的像素信息
- 浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面


## JS 阻塞页面加载
- 为了ui绘制元素不冲突、 GUI 渲染线程与 JavaScript 引擎为`互斥`的关系
- 当浏览器在执行 JavaScript 程序的时候,GUI 渲染线程会被保存在一个`队列`中,直到 JS 程序执行完成,才会接着执行




## defer 和 async 的区别
- 没有以上、浏览器立即执行、不过以上都仅适用于外部脚本
- 允许`<script>`异步加载
    - `async` async属性告诉浏览器先把文件下载下来，在“时机成熟”的时候再执行
    - `defer` 通知浏览器该脚本将在`文档完成解析后`，触发 DOMContentLoaded 事件前执行
- es6 module
    - `type = module`

## 浏览器的回流与重绘
- `回流` 元素的尺寸、结构、或某些属性发生改变时,浏览器`重新渲染`部分或全部文档的过程
  - 首次渲染、页面大小改变、元素尺寸、字体大小、删除添加dom、激活伪类
- `重绘` 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等）,浏览器会将新样式赋予给元素并`重新绘制`它
- 回流必将引起重绘,重绘不一定会引起回流
- 如何避免？
  - 避免使用 table 布局。
  - 避免设置`多层`内联样式。
  - 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。
  - 避免使用 CSS 表达式（例如：calc()）。
  - 避免频繁操作样式,最好一次性重写 style 属性,或者将样式列表定义为 class 并一次性更改 class 属性。
  - 避免频繁操作 DOM
  - display: none,操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
  - 对具有复杂动画的元素使用绝对定位,使它脱离文档流,否则会引起父元素及后续元素频繁回流。
