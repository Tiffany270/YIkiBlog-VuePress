# vue源码 构造和合并

:) 从现在开始好好学习

## 目录结构
- `benchmarks` 性能、基准测试
- `dist` 打包输出
- `flow` flow 语法类型声明 理解为约束接口吧哈哈
- `packages` 一些额外的包
- `scripts` 所有配置文件的存放位置
- `src` 源码开始
  - `compiler` 编译器
  - `core` 核心 你要学的都在里面啦
    - `config.js` 默认配置
    - `index.js` 入口
    - `components` 全局组件 keep-alive
    - `globle-api` 全局api 
    - `instacne` vue实例开始
    - `observer` 响应式原理
    - `util` 工具方法
    - `vdom` 虚拟dom和渲染和patch相关
  - `platforms` 平台相关
  - `server` 服务器渲染相关
- `test`
- `types` ts类型声明 对应一下flow

## GlobalAPI
- `src/globalapi/`下的所有
- `src/core/index.js` 当这里是入口吧
``` js
import Vue from './instance/index' 
import { initGlobalAPI } from './global-api/index'
...
initGlobalAPI(Vue) //这里的vue从instence里来的
... 
```
- 静态属性方法 `src/globalapi/inde.js`
  - `initGlobalAPI` 全局api方法
    ``` js
    ...
    // 对config的处理
    const configDef = {}
    configDef.get = () => config
    if (process.env.NODE_ENV !== 'production') {
        configDef.set = () => {
        warn(
            'Do not replace the Vue.config object, set individual fields instead.'
        )
        }
    }
    Object.defineProperty(Vue, 'config', configDef)
    //...

    Vue.set = set
    Vue.delete = del
    Vue.nextTick = nextTick

    //option    
    Vue.options = Object.create(null)
    // 'component','directive','filter'
    ASSET_TYPES.forEach(type => {
        Vue.options[type + 's'] = Object.create(null)
    })
    //还有一些绑定在component上的扩展，见builtInComponents里
    extend(Vue.options.components, builtInComponents)
    //
    initUse(Vue)//Vue.use = function (plugin: Function | Object)
    initMixin(Vue)// Vue.mixin = function (mixin: Object)
    initExtend(Vue)// Vue.extend = function (extendOptions: Object): Function 
    initAssetRegisters(Vue) //ASSET_TYPES 'component','directive','filter'

    ```
  - `builtInComponents`
- `Vue.extend` 子类构造器 `src/globalapi/extend.js`
  - 复习下怎么用
  ``` js
  // 创建构造器
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Walter',
        lastName: 'White',
        alias: 'Heisenberg'
      }
    }
  })
  //----------------------
  // 创建 Profile 实例，并挂载到一个元素上。
  <div id="mount-point"></div>
  new Profile().$mount('##mount-point')
  // ---------------------
  // res
  <p>Walter White aka Heisenberg</p>
  ```
  - 先创建一个类Sub，接着通过原型继承的方式将该类继承基础Vue类，然后给Sub类添加一些属性以及将父类的某些属性复制到Sub类上，最后将Sub类返回
  ``` js
  Vue.extend = function (extendOptions: Object): Function {
      extendOptions = extendOptions || {}
      const Super = this // yiki: point to Class `Vue`
      const SuperId = Super.cid // yiki: unique identifier 
      const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {}) // pool

      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId]
      }

      const name = extendOptions.name || Super.options.name
      if (process.env.NODE_ENV !== 'production' && name) {
        validateComponentName(name) // 校验
      }

      // yiki: sub class 继承开始
      const Sub = function VueComponent (options) {
        this._init(options)
      }
      Sub.prototype = Object.create(Super.prototype)
      Sub.prototype.constructor = Sub
      Sub.cid = cid++ // identifier
      Sub.options = mergeOptions(
        Super.options,
        extendOptions
      )
      // 将父类保存到子类的super属性中，以确保在子类中能够拿到父类
      Sub['super'] = Super
      
      // ---- 初始化props和computed  
      if (Sub.options.props) {
        initProps(Sub)
      }
      if (Sub.options.computed) {
        initComputed(Sub)
      }
      // copy
      Sub.extend = Super.extend
      Sub.mixin = Super.mixin
      Sub.use = Super.use

      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type]
      })
      if (name) {
        Sub.options.components[name] = Sub
      }
      // 给子类新增三个独有的属性
      Sub.superOptions = Super.options
      Sub.extendOptions = extendOptions
      Sub.sealedOptions = extend({}, Sub.options)

      // yiki: When sub class is created , use Fater class's cid as key, then store to `cachedCtors`
      // cache constructor
      cachedCtors[SuperId] = Sub
      return Sub
    }
  ```
## instance
- src/core/instance/index.js
    ``` js
    // yiki1 打包后的源码是遵从UMD规范的，它是commonjs和amd的整合。
    // 而Vue的本质是一个构造器,并且它保证了只能通过new实例的形式去调用，而不能直接通过函数的形式使用
    function Vue (options) {
    if (process.env.NODE_ENV !== 'production' &&
        !(this instanceof Vue)
    ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
    }
    this._init(options)
    }
    // 定义Vue原型上的init方法(内部方法)
    initMixin(Vue)
    // 定义原型上跟数据相关的属性方法
    stateMixin(Vue)
    //定义原型上跟事件相关的属性方法
    eventsMixin(Vue)
    // 定义原型上跟生命周期相关的方法
    lifecycleMixin(Vue)
    // 定义渲染相关的函数
    renderMixin(Vue)

    export default Vue
    ```

## initMixin 
- 原型上的`_init`方法
``` js
Vue.prototype._init = function (options?: Object)
...
 vm.$options = mergeOptions(// 合并选项（这是用我们写的option）
        resolveConstructorOptions(vm.constructor),// 返回构造函数自身的配置项
        options || {},
        vm
      )
...
if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)// 响应式拦截代理
    } else {
      vm._renderProxy = vm
    }
...
 // expose real self
    vm._self = vm
    initLifecycle(vm) //$parent $childeren
    initEvents(vm) // 自定义事件
    initRender(vm) // 插槽相关 vm.$slot
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm) // 响应式
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) { //挂载
      vm.$mount(vm.$options.el)
    }
  }
```
- 选项合并 `mergeOptions`
``` js
vm.$options = mergeOptions(// 合并选项（这是用我们写的option）
resolveConstructorOptions(vm.constructor),// 返回构造函数自身的配置项
options || {},
vm
)
```
- 响应式数据拦截 `initProxy(vm)`
``` js
 if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)// 响应式拦截代理
    } else {
      vm._renderProxy = vm
  }

  // ----- in proxy.js
  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      const options = vm.$options
      const handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler
      vm._renderProxy = new Proxy(vm, handlers)// 代理vm实例到vm属性
    } else {
      vm._renderProxy = vm
    }
  }
```
- `initLifecycle` instance/lifecycle.js
- `$parent $parent $parent $parent`
```js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$parent = parent ? parent.$root : vm

  vm.$parent = []
  vm.$parent = {}

  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```
- `initState(vm)` /core/instance/state.js
- 响应式！
``` js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props) // props
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)//响应式的入口
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

## stateMixin
- 跟数据相关的属性方法
``` js
Object.defineProperty(Vue.prototype, '$data', dataDef)
Object.defineProperty(Vue.prototype, '$props', propsDef)
Vue.prototype.$set = set
Vue.prototype.$delete = del
Vue.prototype.$watch = function (...)
```

## eventsMixin
- /instance/events.js
- 对原型上的事件相关方法
``` js
Vue.prototype.$on = function (...)
Vue.prototype.$once = function (...)
Vue.prototype.$off = function()
Vue.prototype.$emit = function(
  ...
  let cbs = vm._events[event]
    if (cbs) {
      ...
)
```
- vue在实例上用了一个`vm_events`属性来存储管理事件的派发和更新，并暴露了这些api给外鼓管理和派发
- 理解`$emit`通信原理就是事件监听的回调卸载了父组件中

## lifecycleMixin
- 生命周期相关
``` js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean)
Vue.prototype.$forceUpdate = function ()
Vue.prototype.$destroy = function () 
```
## renderMixin
- /instance/render.js
- 渲染相关
``` js
Vue.prototype.$nextTick = function()
Vue.prototype._render = function (): VNode 
```
## mergeOptions
- /src/core/util/options.js,同一个文件里面有很多关于合并选项的规则
``` js
/**
* Merge two option objects into a new one.
* Core utility used in both instantiation and inheritance.
*/
export function mergeOptions (
parent: Object,
child: Object,
vm?: Component
): Object {
if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)// 拿到option之前要先校验规范
}
if (typeof child === 'function') {
    child = child.options
}
// props,inject,directives的校验和规范化
normalizeProps(child, vm)
normalizeInject(child, vm)
normalizeDirectives(child)
// 扩展子类构造器
if (!child._base) {
    if (child.extends) {
    parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
    for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
    }
    }
}
const options = {}
let key
for (key in parent) {
    mergeField(key)
}
for (key in child) {
    if (!hasOwn(parent, key)) {
    mergeField(key)
    }
}
function mergeField (key) {
    // 拿到指定的选项配置，如果没有则用默认的配置
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
}
return options
}

```
- `validateComponentName() `注册组件名的规则
- `normalizeProps()`
- `normalizeInject()` 用于`provide/inject`的规则
- `normalizeDirectives()` 针对`directives`会针对写法将行为赋予`bind/update`钩子
``` js
...
    if (typeof def === 'function') {
    dirs[key] = { bind: def, update: def }
    }
```
- el 的合并
``` js
strats.el = strats.propsData = function (parent, child, vm, key) {
if (!vm) {// 只允许vue实例才能拥有el属性，其他子类不允许
    warn(
    `option "${key}" can only be used during instance ` +
    'creation with the `new` keyword.'
    )
}
return defaultStrat(parent, child)
}
}
```
- data 的合并
``` js
/**
 * Data
 * 合并返回mergeDatafn or mergedInstanceDataFn funciton
 * 为了复用，每次创建都在一个闭包里，相当于独立的空间，这样每个组件之间的数据就不会相互影响
 */
export function mergeDataOrFn (
  parentVal: any,
  childVal: any,
  vm?: Component
): ?Function {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      const instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal
      const defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData // 不传递data时返回默认
      }
    }
  }
}
strats.data = function (
  parentVal: any,
  childVal: any,
  vm?: Component
): ?Function {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {// 保证子类data是一个函数
      process.env.NODE_ENV !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      )
      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }
  return mergeDataOrFn(parentVal, childVal, vm)
}
```
- watch选项合并

## new vue 过程
- 初始化 合并选项 
- 初始化组建实例的关系 $pariet
- 自定义事件 生命周期
- 数据响应式 
- 配置上有el 调用$mount挂载
