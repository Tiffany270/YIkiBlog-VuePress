# Functions
::: tip
 TypeScript has many ways to describe how functions can be called. Let’s learn about how to write types that describe functions
:::
## Basic
- TypeScript allows you to specify the types of both the `input` and `output` values of `function`
``` ts
// with `string` parameter and return `number`
function greet(name: string): number {
  console.log("Hello, " + name.toUpperCase() + "!!");
  return 26;
}
```
- `fn: (a: string) => void` means with one `string` parameter, and `doesn’t` have a `return` value
```ts
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}
function p(s: string) {
  console.log(s);
}
greeter(p);
//------------
// type alias to name a function type
type GreetFunction = (a: string) => void;
function greeter(fn: GreetFunction) {
  // ...
}
```
- NOTE: In JavaScript, functions can have properties in `addition` to being callable and  invoked with the `new operator`. However, the `function type expression` syntax `doesn’t` allow for `declaring` properties.

## Signatures
- If we want to describe something callable with properties, write a `call signature` in an object type
``` ts
type d = {
  description: string;
  (someArg: number): boolean; // here is a call signature
};
function doSomething(fn: d) {
  console.log(fn.description + " returned " + fn(6)); //see fu (...)
}
```
- You can write a `construct signature` by adding the `new` keyword in front of a `call signature`
``` ts
type s = {
  new (s: string): SomeObject;
};
function fn(ctor: s) {
  return new ctor("hello"); // see new 
}
```
## Generic Functions
- generics are used when we want to describe a `correspondence` between `two` values.
- key word : `constrained` 
``` ts
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}
// s is of type 'string'
const s = firstElement(["a", "b", "c"]);
// n is of type 'number'
const n = firstElement([1, 2, 3]);
// u is of type undefined
const u = firstElement([]);
``` 
## Optional Parameters
- callers can always pass `undefined`, as this simply simulates a “missing” argument
``` ts
function f(x?: number) {
  // ...
}
f(); // OK
f(10); // OK
f(undefined); // ok

// set default
function f(x = 10) {
  // ...
}
```
- When writing a` function type` for a `callback`, `never` write an `optional parameter` unless you intend to call the function `without` passing that `argument`
``` ts
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

myForEach([1, 2, 3], (a, i) => {
  console.log(i.toFixed());
// i Object is possibly 'undefined'.
});
```

## Function Overloads
-  In TypeScript, called in a `variety` of argument counts and types we can specify a function that can be called in different ways by writing `overload signatures`
``` ts
function fn(x: boolean): void; //signature1
function fn(x: string): void;//signature2

function fn(x: boolean) {}// error

function fn(x: boolean | string) {} //right, u must contain all param types
```