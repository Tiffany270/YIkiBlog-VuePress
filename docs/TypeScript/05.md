# Classes
::: tip
Welcome to CLASS chapter!  
TypeScript adds type `annotations` and `other syntax` to allow you to express relationships between classes and other types
::: 
`Getters / Setters` `implements` `extends` `public` `protected` `private` `Static` `abstract`
``` ts
class Point {
  readonly name: string = "world";
  x: number;
  y: number;
}
 
const pt = new Point();
pt.x = 0;
pt.y = 0;
```
---
- `strictPropertyInitialization` setting `OFF/ON` 
  - controls whether class fields `need` to be `initialized` in the `constructor`
``` ts
class GoodGreeter {
  name: string;
 
  constructor() {
    this.name = "hello"; // initialized
  }
}
```

## Super() Calls
-  if you have a `base` class, you’ll need to call `super()` in your `constructor` body before using any this. members
``` ts
class Base {
  k = 4;
}
class Derived extends Base {
  constructor() {
    super(); // before everything
    console.log(this.k);
  }
}
```

## Accessors
``` ts
class C {
  _length = 0;
  get length() {
    return this._length;
  }
  set length(value) {
    this._length = value;
  }
```
- some special inference `rules` 
  - If `get` exists but no `set`, the property is automatically `readonly`
  - If the type of the `setter` parameter is `not` specified, it is `inferred` from the `return` type of the `getter`
  - `Getters` and `setters` must have the `same` [Member Visibility](#member-visibility) 

## Member Visibility
`public` `protected` `private`

## Index Signatures
-  NOTE that it’s `better` to store indexed data in `another` place instead of on the class instance itself
``` ts
class MyClass {
  [s: string]: boolean | ((s: string) => boolean);
 
  check(s: string) {
    return this[s] as boolean;
  }
}
```

## Class Heritage
`implements` `extends` `super`
- Like other languages with object-oriented features, classes in JavaScript can inherit from base classes
---
- `implements`
  - it's only a `check` that the class can be treated as the `interface` type. It `doesn’t` change the type of the class or its methods `at all`
  - `implementing` an `interface` with an optional property `doesn’t` create that property
``` ts
interface A {
  x: number;
  y?: number;
  check(name: string): boolean;
}
class C implements A {
  x = 0;
  check(s) {
  return s.toLowercse() === "ok"; // Notice no error here
  }
}
const c = new C();
c.y = 10; // error
```
---
- `extends`
  - Classes may extend from a base class. A derived class has `all` the `properties` and `methods` of its base class, and also define `additional` members
  - A derived class can also `override` a base class field or property, note that it not simply repeat a method but use `super.`
- remember that JavaScript classes are a simple `lookup` object, looking up like a chain
``` ts
class Base {
  greet() {
    console.log("Hello, world!");
  }
}
class Derived extends Base {
  greet(name?: string) { // name must optional
    if (name === undefined) {
      super.greet(); // override
    } else {
      console.log(`Hello, ${name.toUpperCase()}`);
    }
  }
}
 
const d = new Derived();
d.greet(); // Hello, world!
d.greet("reader"); // Hello, reader
```
## Static Members

## Generic Classes

## this 

## Parameter Properties