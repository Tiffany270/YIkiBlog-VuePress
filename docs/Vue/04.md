# vueæºç  æŒ‚è½½å’Œæ¸²æŸ“

## runtime only
- è‡ªå·±åˆ›å»ºvueå®ä¾‹ï¼Œæ‰‹å†™renderå‡½æ•°ä¹Ÿå¯ä»¥æ‰§è¡Œ
``` js
new vue({
    render(h){
        return h('div',this.hi)
    }
})
```
- è¦å€ŸåŠ©`vue-loader`è¿›è¡Œç¼–è¯‘ï¼Œå°†ç¼–è¯‘äº¤ç»™æ’ä»¶å»å®ç°
## runtime + compiler
- å¯ä»¥ç”¨ä¸ªæ¨¡ç‰ˆï¼Œé€šè¿‡æŒ‚è½½ï¼Œæ˜¯åŒ…å«ç¼–è¯‘å™¨çš„ç‰ˆæœ¬
``` js
new vue ({
    template:'{{yiki}}'
})
```
## virtual dom 
- è™šæ‹Ÿdom å°±æ˜¯å°†é¡µé¢æŠ½è±¡ä¸ºjså¯¹è±¡ï¼Œæœ¬è´¨ä½œä¸ºjså’ŒçœŸå®domçš„ä¸­é—´å±‚
- æµè§ˆå™¨æ¸²æŸ“æµç¨‹
    - htmlæ–‡ä»¶è§£ææˆdomæ ‘ğŸŒ²ï¼Œè¯†åˆ«cssæ ·å¼å’Œdomæ ‘åˆå¹¶æˆæ¸²æŸ“æ ‘
    - å¼•æ“è®¡ç®—å…ƒç´ å¹¶ç»˜åˆ¶ï¼Œæœ€ååœ¨å±å¹•ä¸Šè¾“å‡º
    - jsçº¿ç¨‹æ˜¯ç‹¬ç«‹çš„ï¼Œjsæ“ä½œdomï¼Œæ¸²æŸ“å¼•æ“è§¦å‘å›æµæˆ–è€…é‡ç»˜
    - å›æµï¼šä¿®æ”¹å…ƒç´ å°ºå¯¸å˜åŒ–ï¼Œæµè§ˆå™¨é‡æ–°è®¡ç®—å…ƒç´ å¤§å°å’Œä½ç½®å¹¶å°†ç»“æœç»˜åˆ¶å‡ºæ¥
    - é‡ç»˜ï¼šå•çº¯æ”¹å˜é¢œè‰²ï¼Œé‡æ–°ç»˜åˆ¶æ ·å¼
## vnode
- /core/vnode.js
``` js
constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
      ...
  }
```
- `createEmptyVNode` åˆ›å»ºç©ºvnode
- `createTextVNode` 
- /src/core/vdomåŒ…ä¸‹æœ‰å„ç§ç›¸å…³

## æŒ‚è½½
- ä»€ä¹ˆæ˜¯æŒ‚è½½
    - ä¼ é€’templateä¸ºå±æ€§çš„æ¨¡ç‰ˆå­—ç¬¦ä¸²ï¼Œé€šè¿‡ä¸­é—´è¿‡ç¨‹è½¬ä¸ºçœŸå®çš„domèŠ‚ç‚¹ï¼Œå¹¶æŒ‚è½½åˆ°elä»£è¡¨çš„æ ¹ç»“ç‚¹ä¸Šå®Œæˆæ¸²æŸ“
- /core/instance/init.js
``` js
... // ä¸€ç³»åˆ—åˆ«çš„åˆå§‹åŒ–ï¼Œå¼€å§‹mountæŒ‚è½½
 if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
...
```
- /src/platforms/rumtime/index.js
``` js
// public mount method çœŸæ­£çš„æŒ‚è½½æ–¹æ³•
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```
- `mountComponent` /src/core/instance/lifecycle.js
- æ³¨æ„è¿™é‡ŒæŒ‚è½½å‰ä¼šåˆ›å»ºä¸€ä¸ª`watcher`
``` js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
    ...
     updateComponent = () => {
      // renderå‡½æ•°æ¸²æŸ“å‡ºè™šæ‹Ÿdomï¼Œè™šæ‹Ÿdomæ¸²æŸ“æˆçœŸå®dom
      vm._update(vm._render(), hydrating)
    }
    ...
    new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
```
- /src/platforms/entry-runtime-with-compiler.js
``` js
// é‡æ–°å®šä¹‰$mount
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
    // å†…éƒ¨ç¼–è¯‘å™¨ç¼–è¯‘æ¨¡ç‰ˆ
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
   ...
  }
  // æœ€ç»ˆè°ƒç”¨
  return mount.call(this, el, hydrating)
}
...
```
- `template` ä¼šè½¬ä¸ºè¯­æ³•æ ‘ast
- `compileToFunctions`
``` js
 const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,// æ˜¯å¦æ”¹å˜çº¯æ–‡æœ¬æ’å…¥åˆ†éš”ç¬¦
        comments: options.comments // htmlæ³¨é‡Š
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
```
## vm._render
- å›åˆ°`mountComponent` /src/core/instance/lifecycle.js
``` js
 updateComponent = () => {
      // renderå‡½æ•°æ¸²æŸ“å‡ºè™šæ‹Ÿdomï¼Œè™šæ‹Ÿdomæ¸²æŸ“æˆçœŸå®dom
      vm._update(vm._render(), hydrating)
    }
```
- `vm._render` æ˜¯æ‰§è¡Œ`render`æ¸²æŸ“ï¼Œç”Ÿæˆè™šæ‹Ÿdom
- `_render` /core/instance/render.js
``` js
export function renderMixin (Vue: Class<Component>) {
    ...
  Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options
    ...
    let vnode
    try {
      currentRenderingInstance = vm
      // æ•°æ®ä»£ç†è¿‡æ»¤ + call(obj,this) çš„this
      vnode = render.call(vm._renderProxy, vm.$createElement)
    // ç”¨äº render:()=>{return createelement('div',this.message)}
    } catch (e) {
      ...
    } finally {
      currentRenderingInstance = null
    }
   ...
    return vnode
  }
}
```
- `$createElement` in render.js
``` js
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
```
## vm.update
- `vm._update` è½¬ä¸ºçœŸæ˜¯domèŠ‚ç‚¹
- ` _update` in lifecycleMixin
``` js
export function lifecycleMixin (Vue: Class<Component>) {
  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    
  }
```
- `vm.__patch__` æ˜¯æµè§ˆå™¨ç¯å¢ƒä¸‹ `pathc`å‡½æ•°çš„å¼•ç”¨
    - `vm.__patch__`å†…éƒ¨ä¼šé€šè¿‡ `createElm`å»åˆ›å»ºçœŸå®çš„DOMå…ƒç´ ï¼ŒæœŸé—´é‡åˆ°å­`Vnode`ä¼šé€’å½’è°ƒç”¨`createElm`æ–¹æ³•ã€‚
    - `vnode`æ˜¯ä¸€ä¸ªä¸æ–­åˆ›å»ºå­èŠ‚ç‚¹çš„è¿‡ç¨‹

